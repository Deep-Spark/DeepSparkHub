#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <inttypes.h>

#include <sys/time.h>
double cpuSecond(void){
	struct timeval tp;
	gettimeofday(&tp, NULL);
	return ((double)tp.tv_sec + (double)tp.tv_usec*1e-6);
}


uint8_t aes_key[32]; 
uint8_t aes_enckey[32]; 
uint8_t aes_deckey[32];


#define AES_BLOCK_SIZE 16
#define THREADS_PER_BLOCK 128


#define F(x)	(((x)<<1) ^ ((((x)>>7) & 1) * 0x1b))
#define FD(x)	(((x) >> 1) ^ (((x) & 1) ? 0x8d : 0))

const uint8_t AESsbox[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
	0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
	0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
	0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
	0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};


static const uint8_t AESsboxinv[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
	0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
	0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
	0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
	0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
	0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
	0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
	0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

__device__ uint8_t RJ(uint8_t x){
	return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);
}

__device__ void AesSubBytes(uint8_t *buf){
	int i, b;
	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};

	b =buf[0];
	buf[0] = AESsbox[b];
	b =buf[1];
	buf[1] = AESsbox[b];
	b =buf[2];
	buf[2] = AESsbox[b];
	b =buf[3];
	buf[3] = AESsbox[b];
	b =buf[4];
	buf[4] = AESsbox[b];
	b =buf[5];
	buf[5] = AESsbox[b];
	b =buf[6];
	buf[6] = AESsbox[b];
	b =buf[7];
	buf[7] = AESsbox[b];
	b =buf[8];
	buf[8] = AESsbox[b];
	b =buf[9];
	buf[9] = AESsbox[b];
	b =buf[10];
	buf[10] = AESsbox[b];
	b =buf[11];
	buf[11] = AESsbox[b];
	b =buf[12];
	buf[12] = AESsbox[b];
	b =buf[13];
	buf[13] = AESsbox[b];
	b =buf[14];
	buf[14] = AESsbox[b];
	b =buf[15];
	buf[15] = AESsbox[b];

} 


__device__ void AesSubBytes_inv(uint8_t *buf){
	int i, b;
	uint8_t AESsboxinv[256] = {
		0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
		0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
		0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87,
		0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
		0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
		0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
		0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2,
		0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
		0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
		0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
		0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda,
		0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
		0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
		0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
		0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
		0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
		0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea,
		0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
		0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
		0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
		0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
		0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
		0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20,
		0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
		0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
		0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
		0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
		0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
		0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0,
		0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
		0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26,
		0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	};

	b = buf[0];
	buf[0] = AESsboxinv[b];
	b = buf[1];
	buf[1] = AESsboxinv[b];
	b = buf[2];
	buf[2] = AESsboxinv[b];
	b = buf[3];
	buf[3] = AESsboxinv[b];
	b = buf[4];
	buf[4] = AESsboxinv[b];
	b = buf[5];
	buf[5] = AESsboxinv[b];
	b = buf[6];
	buf[6] = AESsboxinv[b];
	b = buf[7];
	buf[7] = AESsboxinv[b];
	b = buf[8];
	buf[8] = AESsboxinv[b];
	b = buf[9];
	buf[9] = AESsboxinv[b];
	b = buf[10];
	buf[10] = AESsboxinv[b];
	b = buf[11];
	buf[11] = AESsboxinv[b];
	b = buf[12];
	buf[12] = AESsboxinv[b];
	b = buf[13];
	buf[13] = AESsboxinv[b];
	b = buf[14];
	buf[14] = AESsboxinv[b];
	b = buf[15];
	buf[15] = AESsboxinv[b];
} 


__device__ void AesAddRoundKeyLow(uint8_t *buf, uint8_t *key){

	buf[15] ^= key[15];
	buf[14] ^= key[14];
	buf[13] ^= key[13];
	buf[12] ^= key[12];
	buf[11] ^= key[11];
	buf[10] ^= key[10];
	buf[9] ^= key[9];
	buf[8] ^= key[8];
	buf[7] ^= key[7];
	buf[6] ^= key[6];
	buf[5] ^= key[5];
	buf[4] ^= key[4];
	buf[3] ^= key[3];
	buf[2] ^= key[2];
	buf[1] ^= key[1];
	buf[0] ^= key[0];
} 



__device__ void AesAddRoundKeyHi(uint8_t *buf, uint8_t *key){

	buf[15] ^= key[31];
	buf[14] ^= key[30];
	buf[13] ^= key[29];
	buf[12] ^= key[28];
	buf[11] ^= key[27];
	buf[10] ^= key[26];
	buf[9] ^= key[25];
	buf[8] ^= key[24];
	buf[7] ^= key[23];
	buf[6] ^= key[22];
	buf[5] ^= key[21];
	buf[4] ^= key[20];
	buf[3] ^= key[19];
	buf[2] ^= key[18];
	buf[1] ^= key[17];
	buf[0] ^= key[16];
} 


__device__ void AesAddRoundKeyCpy(uint8_t *buf, uint8_t *key, uint8_t *cpk){
	int i = 16;

	buf[15] ^= (cpk[15] = key[15]);
	cpk[31] = key[31];
	buf[14] ^= (cpk[14] = key[14]);
	cpk[30] = key[30];
	buf[13] ^= (cpk[13] = key[13]);
	cpk[29] = key[29];
	buf[12] ^= (cpk[12] = key[12]);
	cpk[28] = key[28];
	buf[11] ^= (cpk[11] = key[11]);
	cpk[27] = key[27];
	buf[10] ^= (cpk[10] = key[10]);
	cpk[26] = key[26];
	buf[9] ^= (cpk[9] = key[9]);
	cpk[25] = key[25];
	buf[8] ^= (cpk[8] = key[8]);
	cpk[24] = key[24];
	buf[7] ^= (cpk[7] = key[7]);
	cpk[23] = key[23];
	buf[6] ^= (cpk[6] = key[6]);
	cpk[22] = key[22];
	buf[5] ^= (cpk[5] = key[5]);
	cpk[21] = key[21];
	buf[4] ^= (cpk[4] = key[4]);
	cpk[20] = key[20];
	buf[3] ^= (cpk[3] = key[3]);
	cpk[19] = key[19];
	buf[2] ^= (cpk[2] = key[2]);
	cpk[18] = key[18];
	buf[1] ^= (cpk[1] = key[1]);
	cpk[17] = key[17];
	buf[0] ^= (cpk[0] = key[0]);
	cpk[16] = key[16];
} 


__device__ void AesShiftRows(uint8_t *buf){
	int i, j;

	i = buf[1], buf[1] = buf[5], buf[5] = buf[9], buf[9] = buf[13], buf[13] = i;
	i = buf[10], buf[10] = buf[2], buf[2] = i;
	j = buf[3],buf[3] = buf[15], buf[15] = buf[11], buf[11] = buf[7], buf[7] = j;
	j = buf[14], buf[14] = buf[6], buf[6]  = j;
}


__device__ void AesShiftRows_inv(uint8_t *buf){
	int i, j;
 
	i = buf[1], buf[1] = buf[13], buf[13] = buf[9], buf[9] = buf[5], buf[5] = i;
	i = buf[2], buf[2] = buf[10], buf[10] = i;
	j = buf[3], buf[3] = buf[7], buf[7] = buf[11], buf[11] = buf[15], buf[15] = j;
	j = buf[6], buf[6] = buf[14], buf[14] = j;
} 


__device__ void AesMixColumns(uint8_t *buf){
	int i, a, b, c, d, e;

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];
	e = a ^ b ^ c ^ d;
	buf[0] ^= e ^ RJ(a^b);
	buf[1] ^= e ^ RJ(b^c);
	buf[2] ^= e ^ RJ(c^d);
	buf[3] ^= e ^ RJ(d^a);

	a = buf[4];
	b = buf[5];
	c = buf[6];
	d = buf[7];
	e = a ^ b ^ c ^ d;
	buf[4] ^= e ^ RJ(a^b);
	buf[5] ^= e ^ RJ(b^c);
	buf[6] ^= e ^ RJ(c^d);
	buf[7] ^= e ^ RJ(d^a);

	a = buf[8]; 
	b = buf[9];
	c = buf[10];
	d = buf[11];
	e = a ^ b ^ c ^ d;
	buf[8]  ^= e ^ RJ(a^b);
	buf[9]  ^= e ^ RJ(b^c);
	buf[10] ^= e ^ RJ(c^d);
	buf[11] ^= e ^ RJ(d^a);

	a = buf[12];
	b = buf[13];
	c = buf[14];
	d = buf[15];
	e = a ^ b ^ c ^ d;
	buf[12] ^= e ^ RJ(a^b);
	buf[13] ^= e ^ RJ(b^c);
	buf[14] ^= e ^ RJ(c^d);
	buf[15] ^= e ^ RJ(d^a);
} 


__device__ void AesMixColumns_inv(uint8_t *buf){
	int i, a, b, c, d, e, x, y, z;

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];
	e = a ^ b ^ c ^ d;
	z = (e & 0x80) ? ((e << 1) ^ 0x1b) : (e << 1);
	x = e ^ RJ(RJ(z^a^c));
	y = e ^ RJ(RJ(z^b^d));
	buf[0] ^= x^(((a^b) & 0x80) ? (((a^b) << 1) ^ 0x1b) : ((a^b) << 1));
	buf[1] ^= y^(((b^c) & 0x80) ? (((b^c) << 1) ^ 0x1b) : ((b^c) << 1));
	buf[2] ^= x^(((c^d) & 0x80) ? (((c^d) << 1) ^ 0x1b) : ((c^d) << 1));
	buf[3] ^= y^(((d^a) & 0x80) ? (((d^a) << 1) ^ 0x1b) : ((d^a) << 1));

	a = buf[4];
	b = buf[5];
	c = buf[6];
	d = buf[7];
	e = a ^ b ^ c ^ d;
	z = (e & 0x80) ? ((e << 1) ^ 0x1b) : (e << 1);
	x = e ^ RJ(RJ(z^a^c));
	y = e ^ RJ(RJ(z^b^d));
	buf[4] ^= x^(((a^b) & 0x80) ? (((a^b) << 1) ^ 0x1b) : ((a^b) << 1));
	buf[5] ^= y^(((b^c) & 0x80) ? (((b^c) << 1) ^ 0x1b) : ((b^c) << 1));
	buf[6] ^= x^(((c^d) & 0x80) ? (((c^d) << 1) ^ 0x1b) : ((c^d) << 1));
	buf[7] ^= y^(((d^a) & 0x80) ? (((d^a) << 1) ^ 0x1b) : ((d^a) << 1));

	a = buf[8];
	b = buf[9];
	c = buf[10];
	d = buf[11];
	e = a ^ b ^ c ^ d;
	z = (e & 0x80) ? ((e << 1) ^ 0x1b) : (e << 1);
	x = e ^ RJ(RJ(z^a^c));
	y = e ^ RJ(RJ(z^b^d));
	buf[8]  ^= x^(((a^b) & 0x80) ? (((a^b) << 1) ^ 0x1b) : ((a^b) << 1));
	buf[9]  ^= y^(((b^c) & 0x80) ? (((b^c) << 1) ^ 0x1b) : ((b^c) << 1));
	buf[10] ^= x^(((c^d) & 0x80) ? (((c^d) << 1) ^ 0x1b) : ((c^d) << 1));
	buf[11] ^= y^(((d^a) & 0x80) ? (((d^a) << 1) ^ 0x1b) : ((d^a) << 1));

	a = buf[12];
	b = buf[13];
	c = buf[14];
	d = buf[15];
	e = a ^ b ^ c ^ d;
	z = (e & 0x80) ? ((e << 1) ^ 0x1b) : (e << 1);
	x = e ^ RJ(RJ(z^a^c));
	y = e ^ RJ(RJ(z^b^d));
	buf[12] ^= x^(((a^b) & 0x80) ? (((a^b) << 1) ^ 0x1b) : ((a^b) << 1));
	buf[13] ^= y^(((b^c) & 0x80) ? (((b^c) << 1) ^ 0x1b) : ((b^c) << 1));
	buf[14] ^= x^(((c^d) & 0x80) ? (((c^d) << 1) ^ 0x1b) : ((c^d) << 1));
	buf[15] ^= y^(((d^a) & 0x80) ? (((d^a) << 1) ^ 0x1b) : ((d^a) << 1));
} 

__device__ void aes_expandEncKey_gpu(uint8_t *k, uint8_t rc){

	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};

	k[0] ^= AESsbox[k[29]] ^ (rc);
	k[1] ^= AESsbox[k[30]];
	k[2] ^= AESsbox[k[31]];
	k[3] ^= AESsbox[k[28]];
	rc = F( rc);
	k[4] ^= k[4-4];
	k[4+1] ^= k[4-3];
	k[4+2] ^= k[4-2];
	k[4+3] ^= k[4-1];
	k[8] ^= k[8-4];
	k[8+1] ^= k[8-3];
	k[8+2] ^= k[8-2];
	k[8+3] ^= k[8-1];
	k[12] ^= k[12-4];
	k[12+1] ^= k[12-3];
	k[12+2] ^= k[12-2];
	k[12+3] ^= k[12-1];
	k[16] ^= AESsbox[k[12]];
	k[17] ^= AESsbox[k[13]];
	k[18] ^= AESsbox[k[14]];
	k[19] ^= AESsbox[k[15]];
	k[20] ^= k[20-4];
	k[20+1] ^= k[20-3];
	k[20+2] ^= k[20-2];
	k[20+3] ^= k[20-1];
	k[24] ^= k[24-4];
	k[24+1] ^= k[24-3];
	k[24+2] ^= k[24-2];
	k[24+3] ^= k[24-1];
	k[28] ^= k[28-4];
	k[28+1] ^= k[28-3];
	k[28+2] ^= k[28-2];
	k[28+3] ^= k[28-1];

}


__device__ void aes_expandEncKey_Ongpu(uint8_t *k, uint8_t *rc, const uint8_t *sb){
	int i;
	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};

	k[0] ^= AESsbox[k[29]] ^ (*rc);
	k[1] ^= AESsbox[k[30]];
	k[2] ^= AESsbox[k[31]];
	k[3] ^= AESsbox[k[28]];
	*rc = F( *rc);
	k[4] ^= k[0];
	k[5] ^= k[1];
	k[6] ^= k[2];
	k[7] ^= k[3];
	k[8] ^= k[4];
	k[9] ^= k[5];
	k[10] ^= k[6];
	k[11] ^= k[7];
	k[12] ^= k[8];
	k[13] ^= k[9];
	k[14] ^= k[10];
	k[15] ^= k[11];
	k[16] ^= AESsbox[k[12]];
	k[17] ^= AESsbox[k[13]];
	k[18] ^= AESsbox[k[14]];
	k[19] ^= AESsbox[k[15]];
	k[20] ^= k[16];
	k[21] ^= k[17];
	k[22] ^= k[18];
	k[23] ^= k[19];
	k[24] ^= k[20];
	k[25] ^= k[21];
	k[26] ^= k[22];
	k[27] ^= k[23];
	k[28] ^= k[24];
	k[29] ^= k[25];
	k[30] ^= k[26];
	k[31] ^= k[27];
}

void aes_expandEncKey(uint8_t *k, uint8_t *rc, const uint8_t *sb){
	int i;

	k[0] ^= sb[k[29]] ^ (*rc);
	k[1] ^= sb[k[30]];
	k[2] ^= sb[k[31]];
	k[3] ^= sb[k[28]];
	*rc = F( *rc);

	for(i = 4; i < 16; i += 4){
		k[i] ^= k[i-4];
		k[i+1] ^= k[i-3];
		k[i+2] ^= k[i-2];
		k[i+3] ^= k[i-1];
	}
	k[16] ^= sb[k[12]];
	k[17] ^= sb[k[13]];
	k[18] ^= sb[k[14]];
	k[19] ^= sb[k[15]];

	for(i = 20; i < 32; i += 4){
		k[i] ^= k[i-4];
		k[i+1] ^= k[i-3];
		k[i+2] ^= k[i-2];
		k[i+3] ^= k[i-1];
	}
} 


__device__ void aes_expandDecKey(uint8_t *k, uint8_t *rc){
	int i;

	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};

	k[28] ^= k[24];
	k[29] ^= k[25];
	k[30] ^= k[26];
	k[31] ^= k[27];
	k[24] ^= k[20];
	k[25] ^= k[21];
	k[26] ^= k[22];
	k[27] ^= k[23];
	k[20] ^= k[16];
	k[21] ^= k[17];
	k[22] ^= k[18];
	k[23] ^= k[19];
	k[16] ^= AESsbox[k[12]];
	k[17] ^= AESsbox[k[13]];
	k[18] ^= AESsbox[k[14]];
	k[19] ^= AESsbox[k[15]];
	k[12] ^= k[8];
	k[13] ^= k[9];
	k[14] ^= k[10];
	k[15] ^= k[11];
	k[8] ^= k[4];
	k[9] ^= k[5];
	k[10] ^= k[6];
	k[11] ^= k[7];
	k[4] ^= k[0];
	k[5] ^= k[1];
	k[6] ^= k[2];
	k[7] ^= k[3];
	*rc = FD(*rc);
	k[0] ^= AESsbox[k[29]] ^ (*rc);
	k[1] ^= AESsbox[k[30]];
	k[2] ^= AESsbox[k[31]];
	k[3] ^= AESsbox[k[28]];
} 


void aes_init(uint8_t *k){
	uint8_t rcon = 1;
	int i;
	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};

	for (i = 0; i < sizeof(aes_key); i++){
		aes_enckey[i] = aes_deckey[i] = k[i];
	}
	for (i = 8;--i;){
		aes_expandEncKey(aes_deckey, &rcon, AESsbox);
	}
} 


__global__ void aes_encrypt_on_gpu(uint8_t *buf_d, unsigned long numbytes, uint8_t *aes_enckey_d, uint8_t *aes_key_d){
	unsigned long offset = (blockIdx.x * THREADS_PER_BLOCK * AES_BLOCK_SIZE) + (threadIdx.x * AES_BLOCK_SIZE);
	if (offset >= numbytes)
		return; 
	uint8_t AESsbox[256] = {
		0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
		0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
		0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc,
		0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
		0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
		0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b,
		0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
		0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
		0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17,
		0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
		0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
		0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9,
		0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
		0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
		0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94,
		0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
		0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
	};
	uint8_t i, rcon,j;
	uint8_t buf_t[AES_BLOCK_SIZE];
	uint8_t k;
	memcpy(buf_t, &buf_d[offset], AES_BLOCK_SIZE);
	AesAddRoundKeyCpy(buf_t, aes_enckey_d, aes_key_d);
	rcon = 1;
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox),AesAddRoundKeyLow(buf_t, aes_key_d);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	AesMixColumns(buf_t);
	AesAddRoundKeyHi( buf_t, &aes_key_d[16]);
	AesSubBytes(buf_t);
	AesShiftRows(buf_t);
	aes_expandEncKey_Ongpu(aes_key_d, &rcon, AESsbox);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	memcpy(&buf_d[offset], buf_t, AES_BLOCK_SIZE);
	__syncthreads();
} 



__global__ void aes_decrypt_on_gpu(uint8_t *buf_d, unsigned long numbytes, uint8_t *aes_deckey_d, uint8_t *aes_key_d){
	unsigned long offset = (blockIdx.x * THREADS_PER_BLOCK * AES_BLOCK_SIZE) + (threadIdx.x * AES_BLOCK_SIZE);
	if (offset >= numbytes) { return; }
	uint8_t i, rcon,j;
	uint8_t buf_t[AES_BLOCK_SIZE];

	memcpy(buf_t, &buf_d[offset], AES_BLOCK_SIZE);
	AesAddRoundKeyCpy(buf_t, aes_deckey_d, aes_key_d);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	rcon = 0x80;
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow(buf_t, aes_key_d);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	aes_expandDecKey(aes_key_d, &rcon),AesAddRoundKeyHi(buf_t, &aes_key_d[16]);
	AesMixColumns_inv(buf_t);
	AesShiftRows_inv(buf_t);
	AesSubBytes_inv(buf_t);
	AesAddRoundKeyLow( buf_t, aes_key_d);
	memcpy(&buf_d[offset], buf_t, AES_BLOCK_SIZE);
	__syncthreads();
} 



void aes_encrypt(uint8_t key[32], uint8_t *buf, unsigned long numbytes){
	uint8_t *buf_d = NULL;
	uint8_t *aes_key_d, *aes_enckey_d;

	cudaMemcpyToSymbol(AESsbox, AESsbox, sizeof(uint8_t)*256);
	aes_init(key);

	cudaMalloc((uint8_t**)&buf_d, numbytes);
	cudaMalloc((void**)&aes_enckey_d, sizeof(aes_enckey));
	cudaMalloc((void**)&aes_key_d, sizeof(aes_key));
	cudaMemcpy(buf_d, buf, numbytes, cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();
	cudaMemcpy(aes_enckey_d, aes_enckey, sizeof(aes_enckey), cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();
	cudaMemcpy(aes_key_d, aes_key, sizeof(aes_key), cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();

	dim3 dimBlock(ceil((double)numbytes / (double)(THREADS_PER_BLOCK * AES_BLOCK_SIZE)));
	dim3 dimGrid(THREADS_PER_BLOCK);
	aes_encrypt_on_gpu<<<dimBlock, dimGrid>>>(buf_d, numbytes, aes_enckey_d, aes_key_d);
	cudaDeviceSynchronize();
	cudaMemcpy(buf, buf_d, numbytes, cudaMemcpyDeviceToHost);
	cudaMemcpy(aes_enckey, aes_enckey_d, sizeof(aes_enckey), cudaMemcpyDeviceToHost);
	cudaMemcpy(aes_key, aes_key_d, sizeof(aes_key), cudaMemcpyDeviceToHost);

	cudaFree(buf_d);
	cudaFree(aes_key_d);
	cudaFree(aes_enckey_d);
}


void aes_decrypt(uint8_t key[32], uint8_t *buf, unsigned long numbytes){
	uint8_t *buf_d;
	uint8_t *aes_key_d, *aes_deckey_d;

	cudaMemcpyToSymbol(AESsboxinv, AESsboxinv, sizeof(uint8_t)*256);

	cudaMalloc((void**)&buf_d, numbytes);
	cudaMalloc((void**)&aes_deckey_d, sizeof(aes_deckey));
	cudaMalloc((void**)&aes_key_d, sizeof(aes_key));

	cudaMemcpy(buf_d, buf, numbytes, cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();
	cudaMemcpy(aes_deckey_d, aes_deckey, sizeof(aes_deckey), cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();
	cudaMemcpy(aes_key_d, aes_key, sizeof(aes_key), cudaMemcpyHostToDevice);
	cudaDeviceSynchronize();

	dim3 dimBlock(ceil((double)numbytes / (double)(THREADS_PER_BLOCK * AES_BLOCK_SIZE)));
	dim3 dimGrid(THREADS_PER_BLOCK);
	aes_decrypt_on_gpu<<<dimBlock, dimGrid>>>(buf_d, numbytes, aes_deckey_d, aes_key_d);
	cudaDeviceSynchronize();
	cudaMemcpy(buf, buf_d, numbytes, cudaMemcpyDeviceToHost);
	cudaMemcpy(aes_deckey, aes_deckey_d, sizeof(aes_deckey), cudaMemcpyDeviceToHost);
	cudaMemcpy(aes_key, aes_key_d, sizeof(aes_key), cudaMemcpyDeviceToHost);

	cudaFree(buf_d);
	cudaFree(aes_key_d);
	cudaFree(aes_deckey_d);
}

int main(){

	FILE *file;
	uint8_t *buf_h; 
	unsigned long numbytes;
	const char *fname = "plaintext.txt";
	double start_time, end_time, enc_time, dec_time;
	int padding, i;
	uint8_t aeskey[32];
	int devnu = 0;

	cudaError_t error_id = cudaGetDeviceCount(&devnu);
	if (error_id != cudaSuccess){
		printf("Error: %s\n", cudaGetErrorString(error_id));
		printf("Exiting...\n");
		exit(EXIT_FAILURE);
	}
	if (devnu == 0){
		printf("No available GPU(s) on System\n");
		exit(EXIT_FAILURE);
	}

	file = fopen(fname, "r");
	if (file == NULL) {printf("File %s doesn't exist\n", fname); exit(1); }
	fseek(file, 0L, SEEK_END);
	numbytes = ftell(file);

	fseek(file, 0L, SEEK_SET);
	cudaMallocHost(&buf_h, numbytes * sizeof(uint8_t));
	if(buf_h == NULL) exit(1);
	if (fread(buf_h, 1, numbytes, file) != numbytes)
	{
		exit(EXIT_FAILURE);
	}
	fclose(file);

	padding = numbytes % AES_BLOCK_SIZE;
	numbytes += padding;
	printf("\nplaintext numbytes is %lu Bytes\n", numbytes);

	for (i = 0; i < sizeof(aeskey); i++) aeskey[i] = i;

	start_time = cpuSecond();
	aes_encrypt(aeskey, buf_h, numbytes);
	cudaDeviceSynchronize();
	end_time = cpuSecond();
	enc_time = end_time - start_time;
	printf("\nGPU encrypt used time:%f sec, and save the ciphertext to ciphertext.txt\n",end_time - start_time);
	file = fopen("ciphertext.txt", "w");
	fwrite(buf_h, 1, numbytes, file);
	fclose(file);

	start_time = cpuSecond();
	aes_decrypt(aeskey, buf_h, numbytes);
	cudaDeviceSynchronize();	
	end_time = cpuSecond();
	dec_time = end_time - start_time;
	printf("\nGPU decrypt used time:%f sec,  and save the plaintext to ciphertext-decrypt.txt\n",end_time - start_time);
	printf("\nGPU run AES cost:%f sec\n",enc_time+dec_time);
	file = fopen("ciphertext-decrypt.txt", "w");
	fwrite(buf_h, 1, numbytes - padding, file);
	fclose(file);

	cudaFreeHost(buf_h);
	return EXIT_SUCCESS;
}
